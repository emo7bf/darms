package solvers;
import ilog.concert.IloException;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import utilities.DARMSPureStrategyGenerator;

import models.DARMSModel;
import models.DARMSOutput;
import models.PureStrategy;
import models.Flight;
import models.RiskCategory;
import models.ScreeningOperation;

public class DARMSOptimalSolver{
	protected static final double oracleTerminateThreshold = 0.5;
	
	private DARMSModel model;
	private DARMSMarginalSolver marginalSolver;
	private DARMSOneNormSolver oneNormSolver;
	private DARMSSlave betterResponseSlaveSolver;
	private DARMSSlave bestResponseSlaveSolver;
	
	private double totalMarginalSolveTime;
	private double totalColumnGenerationTime;
	private int masterIterations;
	private int slaveIterations;
	
	private boolean decomposed;
	private boolean betterResponse;
	
	private int warmStartIterations;
	
	private double marginalDefenderPayoff;
	
	private List<PureStrategy> warmStartPureStrategies;
	
	private int iterationCutoff;
	
	public DARMSOptimalSolver(DARMSModel model, int warmStartIterations, int iterationCutoff, boolean decomposed, boolean betterResponse){
		this.model = model;
		this.warmStartIterations = warmStartIterations;
		this.iterationCutoff = iterationCutoff;
		this.decomposed = decomposed;
		this.betterResponse = betterResponse;
		
		this.warmStartPureStrategies = new ArrayList<PureStrategy>();
	}
	
	public DARMSOptimalSolver(DARMSModel model, List<PureStrategy> warmStartPureStrategies, boolean decomposed, boolean betterResponse){
		this.model = model;
		this.warmStartIterations = 0;
		this.decomposed = decomposed;
		this.betterResponse = betterResponse;
		
		this.warmStartPureStrategies = warmStartPureStrategies;
	}
	
	public void solve() throws Exception{
		marginalSolver = new DARMSMarginalSolver(model, true, decomposed, true, false);
		
		oneNormSolver = new DARMSOneNormSolver(model);
		
		if(decomposed){
			betterResponseSlaveSolver = new DARMSDecomposedSlaveSolver(model, betterResponse);
			
			if(betterResponse){
				//bestResponseSlaveSolver = new DARMSDecomposedSlaveSolver(model, false);
			}
			else{
				//bestResponseSlaveSolver = null;
			}
		}
		else{
			betterResponseSlaveSolver = new DARMSSlaveSolver(model, betterResponse);
			
			if(betterResponse){
				//bestResponseSlaveSolver = new DARMSImprovedSlaveSolver(model, false);
			}
			else{
				//bestResponseSlaveSolver = null;
			}
		}
		
		//double oneNormDistance = Double.POSITIVE_INFINITY;
		
		masterIterations = 0;
		slaveIterations = 0;
		totalMarginalSolveTime = 0;
		totalColumnGenerationTime = 0;
		
		//while(oneNormDistance > 0.0001){
			long startMarginalSolveTime = System.currentTimeMillis();
			
			marginalSolver.solve();
			
			marginalDefenderPayoff = marginalSolver.getDefenderPayoff();
			
			totalMarginalSolveTime += (System.currentTimeMillis() - startMarginalSolveTime) / 1000.0;
			
			//masterSolver.writeProblem("DARMS.lp");
			//masterSolver.writeSolution("DARMS.sol");
			
			Map<Integer, Map<Flight, Map<RiskCategory, Map<ScreeningOperation, Double>>>> marginal = marginalSolver.getDefenderMarginalScreeningStrategy();
			
			masterIterations++;
			
			double startColumnGenerationTime = System.currentTimeMillis();
			
			slaveIterations += runSeparationOracle(marginal);
			
			totalColumnGenerationTime += (System.currentTimeMillis() - startColumnGenerationTime) / 1000.0;
			
			//oneNormDistance = oneNormSolver.getOneNormDistance();
								
			//Map<Integer, Map<Flight, Map<RiskCategory, Map<ScreeningOperation, Double>>>>  marginalStrategy = oneNormSolver.getOneNormProjection();

			// Get the new cut (boundary) generated by the separation oracle
			//Map<Integer, Map<Flight, Map<RiskCategory, Map<ScreeningOperation, Double>>>> boundaryCoeff = oneNormSolver.getConstraintCoeff();
		    //double boundaryConstant = -oneNormSolver.getConstraintConst();					
		    
		    //marginalSolver.addMarginalBound(boundaryCoeff, boundaryConstant);
		//}
	}
	
	private int runSeparationOracle(Map<Integer, Map<Flight, Map<RiskCategory, Map<ScreeningOperation, Double>>>> marginal) throws Exception{
		boolean oracleSolved = false;
		int oracleIterN = 0;
		boolean pureStrategyAdded = false;
		double previousDefenderUtility = Double.NEGATIVE_INFINITY;
		
		oneNormSolver.setMarginal(marginal);
		
		String lpFolder = "./lpFolder";
		
		for(PureStrategy p : warmStartPureStrategies){
			oneNormSolver.addPureStrategy(p);
		}
		
		if(oneNormSolver.getNumberPureStrategies() == 0){
			if(warmStartIterations <= 0){
				betterResponseSlaveSolver.initializeReducedCosts();
	           
	        	//slaveSolver.writeProblem(lpFolder + "/slave_iter" + masterIterations +  "_p" + oneNormSolver.getNumberPureStrategies() + ".lp");
	        	betterResponseSlaveSolver.solve();
	        	//slaveSolver.writeSolution(lpFolder + "/slave_iter" + masterIterations +  "_p" + oneNormSolver.getNumberPureStrategies() + "_sol.txt");
	        	
	        	PureStrategy p = betterResponseSlaveSolver.getPureStrategy();
	        	//System.out.println("New Pure Strategy: " + p.toString());
	        	
	        	if(p == null){
	        		bestResponseSlaveSolver.initializeReducedCosts();
		        	bestResponseSlaveSolver.solve();
		        	
		        	p = bestResponseSlaveSolver.getPureStrategy();
		        	
		        	//System.out.println("Iteration " + oracleIterN + ": Better Response Failed. Going to best response.");
	        	}
	        	
	        	oneNormSolver.addPureStrategy(p);
			}
			else{
	        	//DARMSStrategyGenerator generator = new DARMSStrategyGenerator(model, DARMSHelper.getFlooredScreeningStrategy(marginal));
				DARMSPureStrategyGenerator generator = new DARMSPureStrategyGenerator(model);
				
	        	List<PureStrategy> pureStrategies = generator.generateRandomizedPureStrategies(warmStartIterations);
	            
	        	for(PureStrategy p : pureStrategies){
	        		oneNormSolver.addPureStrategy(p);
	        		warmStartPureStrategies.add(p);
	        		//System.out.println("New Pure Strategy " + p.getID() + ": " + p.toString());
	        	}
			}
        	
            pureStrategyAdded = true;
        }
		
		while(!oracleSolved){
			try{
				//oneNormSolver.writeProblem(lpFolder + "/onenorm_iter" + masterIterations +  "_p" + oneNormSolver.getNumberPureStrategies() + ".lp");
				
				oneNormSolver.solve();
				
				//oneNormSolver.writeSolution(lpFolder + "/onenorm_iter" + numIter +  "_p" + oneNormSolver.getNumberPureStrategies() + "_sol.txt");
			}
			catch(Exception e){
				e.printStackTrace();
				System.err.println("Unable to solve the oracle!");
			}
			
			// Set the weight of each target for the slave MILP
			Map<Integer,Map<Flight,Map<RiskCategory,Map<ScreeningOperation,Double>>>> currentReducedCosts = oneNormSolver.getReducedCosts();			
			
			betterResponseSlaveSolver.setReducedCosts(currentReducedCosts);		
			
			//System.out.println(lpFolder + "/slave_iter" + numIter +  "_p" + oneNormSolver.getNumberPureStrategies() + ".lp");
			//slaveSolver.writeProblem(lpFolder + "/slave_iter" + masterIterations +  "_p" + oneNormSolver.getNumberPureStrategies() + ".lp");				
							
			try{
				betterResponseSlaveSolver.solve();
			}
			catch(Exception e){
				e.printStackTrace();
				System.err.println("Unable to solve the slave!");
			}
			
			//slaveSolver.writeSolution(lpFolder + "/slave_iter" + masterIterations +  "_p" + oneNormSolver.getNumberPureStrategies() + "_sol.txt");
			
			PureStrategy p = betterResponseSlaveSolver.getPureStrategy();	
			
			double slaveReducedCost = betterResponseSlaveSolver.getReducedCost();
			
			//System.out.println("Iteration: " + oracleIterN + " Criteria:" + (slaveReducedCost + oneNormSolver.getReducedCostConstant()));
			
			if(p == null){
				bestResponseSlaveSolver.setReducedCosts(currentReducedCosts);		
				bestResponseSlaveSolver.solve();
				
				bestResponseSlaveSolver.writeProblem("BestResponse.lp");
				
				p = bestResponseSlaveSolver.getPureStrategy();
				
				slaveReducedCost = bestResponseSlaveSolver.getReducedCost();
				
				System.out.println("Iteration " + oracleIterN + ": Better Response Failed. Going to best response.");
				System.out.println("Iteration: " + oracleIterN + " Slave Reduced Costs: " + slaveReducedCost);
			}
			
			double curReducedCost = slaveReducedCost + oneNormSolver.getReducedCostConstant();
			
			if(oracleIterN % 10 == 0){
				double currentDefenderUtility = marginalSolver.calculateDefenderPayoff(oneNormSolver.getMarginalStrategy());
				
				double diff = currentDefenderUtility - previousDefenderUtility;
			
				System.out.println(masterIterations + " " +  oracleIterN + " " + curReducedCost + " " + (marginalDefenderPayoff - currentDefenderUtility) + " " + diff);
				
				previousDefenderUtility = currentDefenderUtility;
			}
			
			if(curReducedCost >= -oracleTerminateThreshold || oracleIterN >= iterationCutoff){
				// optimal solution of oralce has found
				oracleSolved = true;	
			}
			
			// Add the newly generated joint schedule to the list 
			if(!oneNormSolver.getPureStrategyList().contains(p)){					
				oneNormSolver.addPureStrategy(p);	
				pureStrategyAdded = true;
			}
			else{
				//System.out.println("Same pure strategy is returned!");
				pureStrategyAdded = false;
			}
			
			oracleIterN++;				
		}
		
		if(pureStrategyAdded){
			try{				
				oneNormSolver.solve();											
			}
			catch(Exception e){
				e.printStackTrace();
				System.err.println("Unable to solve the oracle!");
			}
		}
		
		return oracleIterN;
	}
	
	public double getMarginalDefenderPayoff(){
		return marginalSolver.getDefenderPayoff();
	}
	
	public double getOneNormDefenderPayoff() throws IloException{
		return marginalSolver.calculateDefenderPayoff(oneNormSolver.getMarginalStrategy());
	}
	
	public int getMasterIterations(){
		return masterIterations;
	}
	
	public int getSlaveIterations(){
		return slaveIterations;
	}
	
	public double getOneNormDistance() throws IloException{
		return oneNormSolver.getOneNormDistance();
	}
	
	public Map<PureStrategy, Double> getMixedStrategy() throws IloException{
		return oneNormSolver.getMixedStrategy();
	}
	
	public List<PureStrategy> getWarmStartPureStrategies(){
		return warmStartPureStrategies;
	}
	
	public void v(DARMSOutput output) throws Exception{
		System.out.println("Solving DARMS model... Completed");
		
		System.out.println("Saving output file: " + output.defenderScreeningStrategyFile());
		marginalSolver.writeDefenderScreeningStrategy(output.defenderScreeningStrategyFile());
		
		System.out.println("Saving output file: " + output.defenderPostScreeningStrategyFile());
		marginalSolver.writeDefenderPostScreeningStrategy(output.defenderPostScreeningStrategyFile());
	
		System.out.println("Saving output file: " + output.adversaryStrategiesFile());
		marginalSolver.writeAdversaryStrategies(output.adversaryStrategiesFile());
	
		System.out.println("Saving output file: " + output.adversaryPayoffsFile());
		marginalSolver.writeAdversaryPayoffs(output.adversaryPayoffsFile());
	
		System.out.println("Saving output file: " + output.defenderPayoffsFile());
		marginalSolver.writeDefenderPayoffs(output.defenderPayoffsFile());
	
		System.out.println("Saving output file: " + output.flightRiskCategoryCoverageFile());
		marginalSolver.writeRiskCategoryCoverage(output.flightRiskCategoryCoverageFile());
		
		System.out.println("Saving output file: " + output.passengerDistributionFile());
		marginalSolver.writeTemporalPassengerDistribution(output.passengerDistributionFile());
	}
	
	public static double calculateOneNormDistance(Map<Integer, Map<Flight, Map<RiskCategory, Map<ScreeningOperation, Double>>>>  m1, Map<Integer, Map<Flight, Map<RiskCategory, Map<ScreeningOperation, Double>>>>  m2){
		double oneNormDistance = 0;
		
		for(Integer t : m1.keySet()){
			for(Flight f : m1.get(t).keySet()){
				for(RiskCategory c : m1.get(t).get(f).keySet()){
					for(ScreeningOperation o : m1.get(t).get(f).get(c).keySet()){
						oneNormDistance += Math.abs(m1.get(t).get(f).get(c).get(o) - m2.get(t).get(f).get(c).get(o));
					}
				}
			}
		}
		
		return oneNormDistance;
	}
}